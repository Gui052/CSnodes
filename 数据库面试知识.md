![1](https://github.com/Gui052/CSnodes/blob/master/pic/1.jpg)

![2](https://github.com/Gui052/CSnodes/blob/master/pic/2.jpg)

#### 1.数据库对象：

触发器（Trigger）、表（Table）、视图（View）、存储过程（StoredProcedure）、索引（Index）、缺省值（Default）、图表（Diagram）、用户（User）、规则（Rule）等几类

#### 2. 索引类型：

索引分类：

- **唯一索引**：唯一索引不允许两行具有相同的索引值
- **主键索引**：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空
- **聚集索引**(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个
- **非聚集索引**(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个

优缺点：

- 索引加快数据库的检索速度
- 索引降低了插入、删除、修改等维护任务的速度
- 唯一索引可以确保每一行数据的唯一性
- 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
- 索引需要占物理和数据空间 

mysql的索引：

* B+树索引 （一种聚集索引）
* 哈希索引
* 全文索引

#### 3. 数据库锁

**产生死锁的四个必要条件：**

1.  互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**下列方法有助于最大限度地降低死锁**：

1. 按同一顺序访问对象。
2. 避免事务中的用户交互。
3. 保持事务简短并在一个批处理中。
4. 使用低隔离级别。
5. 使用绑定连接。

并发控制主要采用的技术手段。

**锁的总括**：

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 在查询完数据的时候就把事务锁起来，直到提交事务 。**使用数据库中的锁机制** 
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 在修改数据的时候把事务锁起来。**通过version的方式来进行锁定** 

**封锁粒度**：行级锁以及表级锁。

**封锁类型**：

1. 读写锁（行级锁）

   - 排它锁（Exclusive），简写为 X 锁，又称**写锁**。

   - 共享锁（Shared），简写为 S 锁，又称**读锁**。

     有以下两个规定：

     - 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
     - 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

   锁的兼容关系如下：

   |  -   |  X   |  S   |
   | :--: | :--: | :--: |
   |  X   |  ×   |  ×   |
   |  S   |  ×   |  √   |

2. 意向锁（表级锁）

   意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

   - 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；

   - 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

     通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

     解释如下：

     - 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；
     - S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。

各种锁的兼容关系如下：

|  -   |  X   |  IX  |  S   |  IS  |
| :--: | :--: | :--: | :--: | :--: |
|  X   |  ×   |  ×   |  ×   |  ×   |
|  IX  |  ×   |  √   |  ×   |  √   |
|  S   |  ×   |  ×   |  √   |  √   |
|  IS  |  ×   |  √   |  √   |  √   |

#### 4. drop、delete**与**truncate的区别

SQL中的**drop、delete、truncate**都表示删除，但是三者有一些差别

- **delete和truncate**只删除表的数据不删除表的结构
- 速度,一般来说: **drop> truncate >delete** 
- **delete**语句是dml,这个操作会放到**rollback segement**中，可以进行回滚,事务提交之后才生效;
  如果有相应的**trigger**,执行的时候将被触发. **truncate,drop**是ddl, 操作立即生效,原数据不放到r**ollback segment**中,不能回滚. 操作不触发**trigger**. 

#### 5. 函数依赖

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。

对于 A->B，B->C，则 A->C 是一个传递函数依赖。

#### 6. 范式

数据库设计所遵循的规范

1NF：属性不可分。

2NF（主键）：每个非主属性完全函数依赖于键码。可以通过分解来满足。

3NF（外键）：非主属性不传递函数依赖于键码。

反三范式：有时候为了效率，可以设置重复字段。

#### 7. 数据库事务？

事务是**数据库中完成单一逻辑功能的操作集合**

##### 7.1事务的四个特性

1. **原子性（Atomicity）**
   事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

2. **一致性（Consistency）**
   数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
3. **隔离性（Isolation）**
   一个事务所做的修改在最终提交以前，对其它事务是不可见的。
4. **持久性（Durability）**
   一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。使用重做日志来保证持久性。

数据库事务是指：几个SQL语句，要么全部执行成功，要么全部执行失败。比如银行转账就是事务的典型场景。

数据库事务的三个常用命令：Begin Transaction、Commit Transaction、RollBack Transaction。

#### 8. 什么是数据库约束,常见的约束有哪几种?

数据库约束用于保证数据库表数据的完整性（正确性和一致性）。可以通过定义约束\索引\触发器来保证数据的完整性。

主键约束：primary key；

外键约束：foreign key；

唯一约束：unique；

检查约束：check；

空值约束：not null；

默认值约束：default；

#### 9. 存储过程

1. 创建的时候进行了编译，以后每次存储不需要重新编译
2. 业务复杂的时候，降低网络传输
3. 减少开发人员工作量
4. 安全性高，屏蔽对数据库的直接访问

定义存储过程：

```sql
creat procedure Student(name varchar(45),age int)
begin 
	insert into student value(name,age);
	select max(stuld) id from student;
end
```

#### 10. jdbc的理解，以及PreparedStatement和Statement

java定义接口，屏蔽各个厂商接口的差异。

PreparedStatement是预编译的，速度快，有效防止SQL注入攻击

#### 11. 数据库连接池

1. 限定数据库连接个数，不会导致由于连接过多导致数据库崩溃
2. 数据库每次连接不需要每次都创建或者销毁，节约资源

#### 12.数据库优化

1. 创建索引
2. 分表
3. 读写分离：当一台服务器不能满足需要时，采用读写分离
4. 缓存：redis进行缓存
5. 一些常用的优化技巧

##### 12.1如何查找并定位慢查询

参考网上：

##### 12.2搜索引擎选择MyISAM和InnoDB

|                  | MyISAM |         InnoDB         |
| :--------------: | :----: | :--------------------: |
|     事务支持     | 不支持 |          支持          |
| 查询和添加的速度 |   快   |           慢           |
|     全文索引     |  支持  | MySQL 5.6.4 版本后支持 |
|      锁机制      |  表锁  |      行锁（事务）      |
|       外键       | 不支持 |          支持          |
|                  |        |                        |

##### 12.3合适的索引

- 普通索引：允许重复
- 唯一索引：不允许重复
- 主键索引：随着主键的创建而创建
- 全文索引：

##### 12.4索引使用技巧

**什么时候【要】创建索引**

- 表经常进行 SELECT 操作
- 表很大(记录超多)，记录内容分布范围很广
- 列名经常在 WHERE 子句或连接条件中出现

**什么时候【不要】创建索引**

- 表经常进行 INSERT/UPDATE/DELETE 操作
- 表很小(记录超少)
- 列名不经常作为连接条件或出现在 WHERE 子句中

技巧：

1. 多列索引，不是使用第一部分就不会使用索引
2. like查询，“%”号放到前面是不使用索引的，需要“aa%”将“%”放到后面
3. 条件中有or，如果存在一个不使用索引，那即使里面存在某条件带有索引也不会使用。
4. 如果类型是字符串，一定要将条件中的数据用引号引起来，否则不会使用索引
5. 如果mysql估计使用全表扫描更快，就不会使用索引。比如表中只有一条数据

##### 12.5分表

- 水平分表
  - 按时间分表
  - 按区间范围分表（一般根据自增ID）
  - hash分表（用最多的）
- 垂直分表

##### 12.6读写分离

- 主从同步：

  ​	数据库最终会把数据持久化到磁盘上，如果集群必须确保每一个数据库服务器的数据是一致的，改变数据的操作都放到主数据库，其他数据库从主数据库同步

- 读写分离：

  ​	 使用负载均衡来实现写的操作都往主数据库，读都往从数据库。

##### 12.7缓存

在持久层（DAO）和数据库（DB）之间添加一个缓存层。可以减少数据库压力，减少访问时间

1. redis

##### 12.8语句优化

- DDL（数据库定义语言）优化
  - 通过禁用索引提高导入性能
  - 关闭唯一校验（我们在程序中确保数据都正确）
  - 修改事务提交方式（变多次提交为一次） 
- DML（数据库操纵语言）优化
  - 合并多条SQL语句为一条
- DQL（数据）优化
  - order by优化
    - 多使用索引排序
    - 普通结果排序
  - group by优化
    - 使用order by null取消默认排序
    - 使用跨表查询代替原来的一些查询、
  - limit优化
    - 使用外链接的方式替换原来的一些查询
  - or 优化
    - 所有条件都使用索引

##### 12.9批量插入几百万条数据实现

- 变多次提交为一次
- 使用批量操作
- 像这种批量操作能不使用代码就不使用代码，使用储存过程

#### 13. 关系数据模型

关系数据模型由**关系数据结构**、**关系操作集合**、**关系完整性约束**组成
