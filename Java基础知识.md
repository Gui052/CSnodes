## 1.Java基础

### 1. Java中数据类型以及长度

|  类型   | 位(一个字节8位) |   封装   | 默认值 |
| :-----: | :-------------: | :------: | :----: |
|  byte   |        8        |   Byte   |   0    |
|  short  |       16        |  Short   |   0    |
|   int   |       32        | Interger |   0    |
|  long   |       64        |   Long   |   0L   |
|  float  |       32        |  Float   |  0.0F  |
| double  |       64        |  Double  |  0.0D  |
|  char   |       16        | Charater |   空   |
| boolean |        8        | Boolean  | false  |

### 2. 面向对象四个特征

封装，抽象，继承，多态

### 3. 装箱和拆箱

将基本类型转换为包装类，叫装箱。需要这样转换是因为`java`是面向对象的语言，基本数据类型没有面向对象的特征。

### 4. ==和equals有什么区别

`==` 用来判断变量之间是否相等。如果是基本数据类型，就比较值，如果是引用类型就比较地址。

`equals` 比较的是对象的某些特征是否一样。实际上就是调用对象的equals方法。所有类都是继承Object类，而Object类中默认的equal方法用的就是`==`，所以如果不重写equal方法，就按照`==`的判断方式进行判断。

### 5. String，StringBuilder，StringBuffer有什么不同

String是不可变的字符串 ，底层使用了不可变的数组(final char[] value)。其他两个都是可变字符串，底层使用的是可变数组(没有final修饰)

String str="123"是在常量池中保存，根据字面量如果两个str相同，这两个就都指向同一个引用。而String str=new String("123")是在堆中新建的对象，每一次生成地址都是不同的。

拼接字符串：String的直接 `+` 会创建三个对象，所以使用其他两个效率更高(append方法)。但是如果在处理String + 的时候，JVM会进行优化，实际上是也会new String这样然后使用append()方法。

StringBuilder是线程不安全的，效率高，StringBuffer是线程安全的，效率低

### 6. Java中的集合

常用的集合类有一下几种：

1. List结构的集合类：ArrayList类，LinkedList类，Vector类（矢量队列），Stack类
2. Map结构的集合类：HashMap类，Hashtable类
3. Set结构的集合类：HashSet类，TreeSet类
4. Queue结构的集合：Queue接口

Java中集合分为value，key-value两种。储存value的有List和Set，储存key-value的是Map。

* **List是有序的，可以重复的**。（这里有序是指插入和读取的顺序是否一致）
* **Set是无序的，不可以重复的**。根据equals和hashcode判断，所以存在Set里面的元素，就必须重写equals和hashcode的方法。
* **Map是自动根据key排序的，key不能修改，其对应的value可以更改，不允许key重复**

### 7. ArrayList和LinkList以及Vector，Stack的区别

ArrayList底层使用的是数组。LinkList底层使用的是双链表。所以前者查询特定索引的元素比较快，后者插入删除快。所以ArrayList使用的是查询比较多的场景，LinkList使用的是插入删除比较多的场景。Vector底层实现也是数组，具有ArrayList的性质，但是它是线程安全的。Stack（栈）是Vector的一个子类，它实现了一个标准的后进先出的栈。

### 8. HashMap和HashTable的区别

两者都可以用来存储key-value的数据

* HashMap可以用null作为key或者value，HashTable不行
* HashMap是线程不安全的，效率高。
* HashTable是线程安全的，效率低。
* ConcurrentHashMap是线程安全的，其内部使用了多个HashMap，同步时给内部正在使用的HashMap加锁

### 9. HashSet和TreeSet的区别

**HashSet**

* 不能保证元素的排列顺序，顺序有可能发生变化
* 不是线程安全的
* 集合元素可以是null,但只能放入一个null

**TreeSet**

​      TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序 和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象并且实现Comparable接口

### 10. 拷贝文件使用字节流还是字符流

我们拷贝的文件不知包含字符，为了考虑通用性，要使用字节流。

### 11. 线程的实现方式

* 通过继承Thread类实现
* 通过实现Runable接口实现

Java中只有单继承，如果继承Thread就不能继承其他类了。

怎么启动：

```java
Thread thread=new Thread（继承了Thread的对象/实现了Runable的对象）
thread.setName("设置一个线程名称")
thread.start();
启动后执行run方法。
```

### 12. 线程并发库

java通过Executor提供四种静态方法创建四种线程池

* newCachedThreadPool  创建可缓存线程池 ，如果长度超过所需，可以自动回收空闲线程，如果不够则创建新的。

* **newFixedThreadPool**（常用）创建一个定长线程池，可控制线程最大并发量，超出的线程会在队列中等待

* newScheduledThreadPool  创建一个定长线程池，支持定时以及周期性的执行任务

* newSingleThreadPool  创建一个单线程化的线程池，保证所有线程按照一定顺序（FIFO,UFO，优先级）执行

  作用：

  1. 限制线程个数，不会导致由于线程过多导致溢出。
  2. 线程池不用每次需要再去创建或销毁，节约资源
  3. 不需要每次创建，响应更快

### 13. 常用的设计模式

* 单例模式：
  * 饱汉模式：一开始就创建
  * 饥汉模式：需要时创建，注意多线程的情况，需要进行同步操作
    1. 构造方法私有化
    2. 在自己的类中创建一个单实例
    3. 提供一个方法获取该实例的对象（创建时需要进行方法同步）
* 工厂模式：Spring IOC
  * 对象的创建交给一个工厂去创建，自己不用
* 代理模式：Spring AOP

### 14. forward和redirect

* forward是服务器端跳转，还是原来的请求，链接没有变，效率高

* redirect是客户端的跳转，是重新发起的请求，链接改变，效率低

### 15.session和cookie的区别

都是会话跟踪技术。session是服务端记录，cookie是客户端记录，但是session依赖于cookie，sessionID。所以登录信息放在session中，其他信息放在cookie中（购物车的实现可以放在cookie，但是cookie是可以禁用的，所以需要使用cookie+数据库的方式）

## 2.Java虚拟机

#### 1.Java内存模型

* 程序计数器：选取指令
* 虚拟机栈：描述Java方法执行的内存模型
* 本地方法栈：为Native方法服务
* Java堆：线程共享，垃圾回收器管理主要区域
* 方法区：线程共享，储存已经被虚拟机加载的类信息、常量、静态变量等数据

#### 2.垃圾回收

由于无法解决对象相互引用的问题，引用计数法已不再使用。现在使用**可达性分析法**对对象是否死亡做判断。

##### 1.垃圾回收算法

* 标记-清除算法：效率低，也可用于老生代
* 复制算法：内存代价高（用于新生代）
* 标记-整理算法：好用，用在老生代
* 分代回收算法：针对不同内存区域使用不同算法

#### 3.类加载过程

* 加载：
  * 获取二进制流
  * 将此数据量转化为运行时数据结构
  * 生成一个java.lang.Class对象，作为这个类的各种数据的访问入口
* 验证：文件格式验证，元数据验证，字节码验证，符号引用验证
* 准备：分配内存
* 解析：将常量池符号引用替换为直接引用的过程
* 初始化：执行类中定义的Java代码

#### 4.线程安全和锁优化

##### 1.线程安全

* **互斥同步（阻塞同步，悲观锁）**：同步是保证共享数据某一时刻只被一个线程使用。互斥是同步实现的一种的手段。临界区，信号量，互斥量都是实现互斥的主要方式。最基本的互斥同步手段就是synchronized关键字。除了synchronized之外，我们还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步。不过，相比synchronized，ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。
* **非阻塞同步：基于冲突检测的乐观锁**。由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供CAS指令，这是虚拟机内部进行特殊处理，一般不允许用户进行调用，实在需要，则需要反射手段或者其他API间接调用。
* **无同步方案（一个方法不涉及共享数据）**：可重入代码，线程本地储存

##### 2.锁优化

1. **自旋锁**（自适应自旋锁）：稍微等待但是不放弃CPU使用时间
2. **锁清除**：编译时检查那些要求同步的代码，但实际上不可能发生共享数据竞争的锁并清除（判定依据源于逃逸分析技术）
3. **锁粗化**：一系列操作都是对同一对象反复加减锁，虚拟机会将锁粗化到整个操作序列的外部
4. **轻量级锁**：需要使用CAS操作去消除同步使用的互斥量。对于绝大多数的锁，在整个同步周期内是不存在竞争的。如果存在竞争，上升为重量级锁。有竞争的情况下，除了需要互斥量的开销，还执行了一次CAS操作，这比传统的重量级锁更慢
5. **偏向锁**：如果说轻量级锁在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那么偏向锁则是在无竞争的情况下把整个同步都消除。这个锁会偏向于第一个获得它的线程，如果接下来的执行过程中该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要进行同步

